)]}'
{"version":3,"sources":["simple:reactive-method/reactive-method.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,kB;AACA,K;AACA,4E;AACA,gF;AACA,4E;AACA,uB;AACA,mB;AACA,K;AACA,oB;;AAEA,K;AACA,2E;AACA,8E;AACA,gF;AACA,4E;AACA,gF;AACA,4E;AACA,wB;AACA,I;AACA,gF;AACA,8E;AACA,2B;AACA,I;AACA,kE;AACA,K;AACA,8D;AACA,gE;AACA,K;AACA,mD;AACA,uC;AACA,0C;AACA,yF;AACA,K;;AAEA,oC;AACA,0D;AACA,I;;AAEA,K;AACA,8E;AACA,6B;AACA,8C;AACA,8C;AACA,8C;AACA,K;AACA,4C;AACA,wC;;AAEA,e;AACA,0C;AACA,0F;AACA,K;;AAEA,mE;;;AAGA,0D;AACA,4D;;AAEA,0B;;AAEA,kF;AACA,4E;AACA,wB;AACA,M;AACA,iC;AACA,qD;AACA,iE;AACA,Y;AACA,kF;AACA,mD;AACA,kD;;AAEA,mE;AACA,wD;AACA,wB;AACA,S;AACA,K;;AAEA,0E;AACA,iC;AACA,+B;AACA,qD;;AAEA,sC;AACA,sD;AACA,wD;AACA,yD;AACA,sD;AACA,S;AACA,S;AACA,O;;AAEA,iC;AACA,uB;AACA,yE;AACA,wD;AACA,+B;AACA,O;AACA,O;;AAEA,6B;AACA,I;;AAEA,K;AACA,2E;AACA,yC;AACA,K;AACA,6D;AACA,oC;AACA,6D;AACA,I;;AAEA,K;AACA,8E;AACA,uC;AACA,K;AACA,sD;AACA,mE;;AAEA,wE;AACA,oD;AACA,sB;AACA,O;AACA,G;AACA,E;;AAEA,G;AACA,2E;AACA,+C;AACA,gF;AACA,G;AACA,+D;AACA,2E;AACA,0C;AACA,mE;AACA,gD;AACA,oC;AACA,C;;AAEA,G;AACA,8E;AACA,gC;AACA,4C;AACA,gF;AACA,G;AACA,+D;AACA,oE;AACA,yD;;AAEA,6B;AACA,wC;AACA,6D;AACA,U;AACA,2D;AACA,wD;AACA,G;AACA,C;;AAEA,G;AACA,8E;AACA,+D;AACA,4C;AACA,G;AACA,0C;AACA,2E;AACA,yD;AACA,K;AACA,C","file":"/packages/simple_reactive-method.js","sourcesContent":["ReactiveMethod = {\n  /**\n   * A global object that matches serialized arguments of Method.apply to an\n   * array of computations that depend on the result of that method. Used mainly\n   * to allow invalidation of method results from outside of the computation\n   * using that result.\n   * @type {Object}\n   */\n  _computations: {},\n\n  /**\n   * Call a Meteor method. Can only be used inside a Tracker autorun (which\n   * includes Blaze helpers). Functions much like a promise - on the first run\n   * of the computation returns undefined, and when the method result comes back\n   * reruns the computation and returns the actual result. If this method is\n   * called in consecutive reruns of the computation with the same arguments, it\n   * remembers the previous result, which avoids calling the method over and\n   * over again forever.\n   *\n   * Watch out - if you call this method with a constantly changing value as one\n   * of the arguments (for example the current time or a random value) it will\n   * never return anything.\n   *\n   * The API for the arguments is exactly the same as Meteor.call.\n   * \n   * @param {String} methodName The name of the method to call\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments\n   */\n  call: function (methodName /*, ...arguments */) {\n    if (! Tracker.currentComputation) {\n      // If not in an autorun, throw error\n      throw new Error(\"Don't use ReactiveMethod.call outside of a Tracker computation.\");\n    }\n\n    var args = _.toArray(arguments);\n    return ReactiveMethod.apply(methodName, _.rest(args));\n  },\n\n  /**\n   * Just like ReactiveMethod.call except uses the calling API of Meteor.apply\n   * instead of Meteor.call. \n   * @param  {[type]} methodName [description]\n   * @param  {[type]} methodArgs [description]\n   * @return {[type]}            [description]\n   */\n  apply: function (methodName, methodArgs) {\n    var cc = Tracker.currentComputation;\n\n    if (! cc) {\n      // If not in an autorun, throw error\n      throw new Error(\"Don't use ReactiveMethod.apply outside of a Tracker computation.\");\n    }\n\n    var serializedArgs = EJSON.stringify([methodName, methodArgs]);\n\n\n    cc._reactiveMethodData = cc._reactiveMethodData || {};\n    cc._reactiveMethodStale = cc._reactiveMethodStale || {};\n\n    var methodReturnValue;\n\n    if (cc._reactiveMethodData && _.has(cc._reactiveMethodData, serializedArgs)) {\n      // We are calling the method again with the same arguments, return the\n      // previous result\n      \n      // Mark this result as used\n      delete cc._reactiveMethodStale[serializedArgs];\n      methodReturnValue = cc._reactiveMethodData[serializedArgs];\n    } else {\n      // Only record the method call if it doesn't match the condition above about\n      // being called again with the same arguments\n      recordMethodComputation(cc, serializedArgs);\n\n      Meteor.apply(methodName, methodArgs, function (err, result) {\n        cc._reactiveMethodData[serializedArgs] = result;\n        cc.invalidate();\n      });\n    }\n\n    // Copied logic from meteor/meteor/packages/ddp/livedata_connection.js\n    cc.onInvalidate(function () {\n      // Make sure this is used\n      cc._reactiveMethodStale[serializedArgs] = true;\n\n      Tracker.afterFlush(function () {\n        if (cc._reactiveMethodStale[serializedArgs]) {\n          delete cc._reactiveMethodData[serializedArgs];\n          delete cc._reactiveMethodStale[serializedArgs];\n          deleteMethodComputation(cc, serializedArgs);\n        }\n      });\n    });\n\n    cc.onInvalidate(function () {\n      if (cc.stopped) {\n        // Delete this computation from global computation store to avoid\n        // keeping a reference to every computation ever\n        cleanUpComputation(cc);\n      }\n    });\n\n    return methodReturnValue;\n  },\n\n  /**\n   * Invalidate all computations that are currently depending on the result\n   * of a particular ReactiveMethod.call.\n   */\n  invalidateCall: function (methodName /*, ...arguments */) {\n    var args = _.toArray(arguments);\n    ReactiveMethod.invalidateApply(methodName, _.rest(args));\n  },\n\n  /**\n   * Invalidate all computations that are currently depending on the result of\n   * a particular ReactiveMethod.apply.\n   */\n  invalidateApply: function (methodName, methodArgs) {\n    var serializedArgs = EJSON.stringify([methodName, methodArgs]);\n\n    _.each(ReactiveMethod._computations[serializedArgs], function (cc) {\n      delete cc._reactiveMethodData[serializedArgs];\n      cc.invalidate();\n    });\n  }\n};\n\n/**\n * Record that a computation is using the result of a method call, to allow\n * invalidation from outside of the computation\n * @param  {String} serializedArgs Arguments to Method.apply, in serialized form\n */\nfunction recordMethodComputation(computation, serializedArgs) {\n  // Add computation to the list of computations using these arguments, and\n  // create the array if it doesn't exist.\n  var initial = ReactiveMethod._computations[serializedArgs] || [];\n  ReactiveMethod._computations[serializedArgs] =\n    _.union(initial, [computation]);\n}\n\n/**\n * Remove the computation from the global dictionary of which computations are\n * watching which method results\n * @param  {Tracker.Computation} computation\n * @param  {String} serializedArgs Arguments to Method.apply, in serialized form\n */\nfunction deleteMethodComputation(computation, serializedArgs) {\n  var methodsForArgs = ReactiveMethod._computations[serializedArgs];\n  var withoutCC = _.without(methodsForArgs, computation);\n\n  if (withoutCC.length > 0) {\n    // Remove computation from the array\n    ReactiveMethod._computations[serializedArgs] = withoutCC;\n  } else {\n    // Delete the array if it is empty to avoid memory leak\n    delete ReactiveMethod._computations[serializedArgs];\n  }\n}\n\n/**\n * Remove all references to the computation from global cache of computations,\n * used to avoid memory leaks from storing stopped computations\n * @param  {Tracker.Computation} computation\n */\nfunction cleanUpComputation(computation) {\n  _.each(computation._reactiveMethodData, function (data, serializedArgs) {\n    deleteMethodComputation(computation, serializedArgs);\n  });\n}\n"]}